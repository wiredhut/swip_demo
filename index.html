<!DOCTYPE html>
<html>
<head>
	<title>
		SWIP-DEMO
	</title>

	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
   integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ=="
   crossorigin=""/>

	<!-- JQuery-->
	<script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

	<!-- data picker -->
	<script src="jquery.simple-dtpicker.js"></script>
	<link type="text/css" href="jquery.simple-dtpicker.css" rel="stylesheet" />

   <!-- Make sure you put this AFTER Leaflet's CSS -->
   <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"
   integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ=="
   crossorigin=""></script>


   <link rel="stylesheet" type="text/css" href="main.css">
   
   <link href="https://fonts.googleapis.com/css?family=Noto+Sans:400,400i,700,700i&amp;subset=cyrillic"
          rel="stylesheet">

	<script src="heatmap.js"></script>
	<script src="leaflet-heatmap.js"></script>
	<script src="wiket.js"></script>

	<script src="https://unpkg.com/leaflet-tilelayer-swiss@2.0.1/dist/Leaflet.TileLayer.Swiss.umd.js" crossorigin
        integrity="sha384-QQS8FVB6RhNfzlOqzJV3/V4P6YNJSs49djuAoMAh2NJ5BNaYxPCC1t14fwtcg90/"></script> 

</head>
<body>
	<div class="headerInfo" onclick="toggleDescription(true)">
    	<div class='header'>SWIP DEMO</div>
    	<div class='project_info' onclick="toggleDescription(true)"><img src="./src/info.svg" style="width:35px;height:35px;center"></div>
    </div>
    
    <div id='description'>
      <div class="tab">
        <div class="tablinks" onclick="openTab(event,'project')" id="defaultOpen"> SWIP DEMO</div>
        <button id="closeButton" class="tablinks" onclick="toggleDescription(false)">
          <img src="./src/close.svg" style="width:33px;height:28px;">
        </button>
      </div>
      <div id="project" class="tabcontent">
		<label for="zones">Zone:</label>
		<select name="zones" id="zones">
		</select>
		Date:<input type="text" name="date" value="">
		<div id="loading"></div>
      </div>
    </div>

    <div id="map" style="height: 100vh; width: 100vw; z-index: 0"></div>
	<div class="tooltip" style="display: none; transform: translate(821px, 58px);">0</div>


	<div id="heatmapLegend">
		<h2>People Density Legend</h2>
		<span id="min"></span>
		<span id="max"></span>
		<img id="gradient" src="" style="width:100%" />
	</div>

	<script>
	  $(function(){
		$('*[name=date]').appendDtpicker({
			"dateFormat":"YYYY-MM-DDThh:mm",
			"inline":true,
			"minuteInterval": 60
		});
		});

		

		// we want to display the gradient, so we have to draw it
        var legendCanvas = document.createElement('canvas');
        legendCanvas.width = 100;
        legendCanvas.height = 10;

        var legendCtx = legendCanvas.getContext('2d');
        var gradientCfg = {};

		function updateLegend(data) {
          // the onExtremaChange callback gives us min, max, and the gradientConfig
          // so we can update the legend
          document.getElementById('min').innerHTML = data.min;
          document.getElementById('max').innerHTML = data.max;
          // regenerate gradient image
          if (data.gradient != gradientCfg) {
            gradientCfg = data.gradient;
            var gradient = legendCtx.createLinearGradient(0, 0, 100, 1);
            for (var key in gradientCfg) {
              gradient.addColorStop(key, gradientCfg[key]);
            }

            legendCtx.fillStyle = gradient;
            legendCtx.fillRect(0, 0, 100, 10);
            document.getElementById('gradient').src = legendCanvas.toDataURL();
          }
        };

		var cfg = {
			// radius should be small ONLY if scaleRadius is true (or small radius is intended)
			// if scaleRadius is false it will be the constant radius used in pixels
			"radius": 0.000015,
			"maxOpacity": .8,
			// scales the radius based on map zoom
			"scaleRadius": true,
			// if set to false the heatmap uses the global maximum for colorization
			// if activated: uses the data maximum within the current map boundaries
			//   (there will always be a red spot with useLocalExtremas true)
			"useLocalExtrema": false,
			// which field name in your data represents the latitude - default "lat"
			latField: 'x',
			// which field name in your data represents the longitude - default "lng"
			lngField: 'y',
			// which field name in your data represents the data value - default "value"
			valueField: 'predicted',
			onExtremaChange: function onExtremaChange(data) {
				updateLegend(data);
			}
		};
											
	</script>

	 <script type="text/javascript">

	 	livehoods_style = 'mapbox://styles/artemkonuchovwiredhut/cl1j7more00lf14o300x3xmvi';
	 	
		var accessToken = 'pk.eyJ1IjoiYXJ0ZW1rb251Y2hvdndpcmVkaHV0IiwiYSI6ImNsMWo3amg3czBtMmUzYnFsNHFhMHZiMWQifQ.sWe8oS5qb0EfQeDd-oq_hQ';

		var map = L.map('map', {crs: L.CRS.EPSG21781, maxZoom:22});
 
		var current_style = livehoods_style;

		var swissLayer = L.tileLayer.swiss({ crs: L.CRS.EPSG21781 }).addTo(map);
		

		map.setView(L.CRS.EPSG21781.unproject(L.point(682170.102908364962786, 250069.716387805819977)), 18);

		L.control.zoom({
		     position:'bottomright'
		}).addTo(map);

		var heatmapLayer = new HeatmapOverlay(cfg);

		map.addLayer(heatmapLayer); 
		

		const loader = document.querySelector("#loading")
		
		//show loading
		function displayLoading() {
			loader.classList.add("display")
		}

		//hiding loading
		function hideLoading() {
			loader.classList.remove("display");
		}


		function update_forecast() {
			var zone = $("#zones").val();
			var datetime = $('*[name=date]').val()
			if (zone) {
				displayLoading();
				const query = `https://swip.wiredhut.com/api/forecast?zone_id=${zone}&datetime=${datetime}&model=simple`;
				fetch(query)
					.then(response => response.json())
					.then((json) => { return json.map(function(val){
						unprojected = L.CRS.EPSG21781.unproject(L.point(val['x'], val['y']))
						return {
							"x": unprojected['lat'],
							"y": unprojected['lng'],
							"predicted": val['predicted']
						}
					})} )
					.then((unprojected) => {
						predicted_values = []
						for (i in data){
							values.push(data['predicted')
						}
						data = {
							max:Math.max.apply(null, predicted_values),
							min: 0,
							data: unprojected
						}
						heatmapLayer.setData(data);
						hideLoading();
					})
				}
		}

		$('*[name=date]').on('change', function(){
			update_forecast(this.value);
		});

		function toggleDescription(show) {
		  if(show) { description.style.left="0"; }
		  else { description.style.left="-100%"; }
		}


		function openTab(evt,tabName) {
		      var i, tabcontent, tablinks;
		      tabcontent = document.getElementsByClassName("tabcontent");
		      for (i = 0; i < tabcontent.length; i++) {
		          tabcontent[i].style.display = "none";
		      }
		      tablinks = document.getElementsByClassName("tablinks");
		    for (i = 0; i < tablinks.length; i++) {
		        tablinks[i].className = tablinks[i].className.replace(" active", "");
		    }
		    document.getElementById(tabName).style.display = "block";
		    evt.currentTarget.className += " active";
		}

	 </script>

	
	<script type="text/javascript">
		//Fill zone dropdown with
		let zone_dropdown = $("#zones")
		zone_dropdown.empty();
		zone_dropdown.append('<option selected="true" disabled>Choose zone</option>');
		zone_dropdown.prop('selectedIndex', 0);

		const url = 'https://swip.wiredhut.com/api/zones/'
		$.getJSON(url, function (data) {
			$.each(data, function (key, entry) {
				zone_dropdown.append($('<option></option>').attr('value', entry['id']).text(entry['id']));
			})
		});
		
		$('#zones').on('change', function(){
			//get zone geometry
			const query = `https://swip.wiredhut.com/api/zones/${this.value}`;
			$.getJSON(query, function(data){
				var wkt = new Wkt.Wkt()
				polygon = wkt.read(data['geom'])
				first_component = polygon.components[0][0]
				map.setView(L.CRS.EPSG21781.unproject(L.point(first_component['x'], first_component['y'])), 18);
			})

			update_forecast();
		});

	</script>

	<script>
		/* tooltip code start */
		var demoWrapper = document.querySelector('#map');
		var tooltip = document.querySelector('.tooltip');
		function updateTooltip(x, y, value) {
		// + 15 for distance to cursor
			var transl = 'translate(' + (x + 15) + 'px, ' + (y + 15) + 'px)';
			tooltip.style.webkitTransform = transl;
			tooltip.innerHTML = value;
		};
		demoWrapper.onmousemove = function(ev) {
		var x = ev.layerX;
		var y = ev.layerY;
		// getValueAt gives us the value for a point p(x/y)
		var value = heatmapLayer._heatmap.getValueAt({
			x: x,
			y: y
		});
		tooltip.style.display = 'block';
		updateTooltip(x, y, value);
		};
		// hide tooltip on mouseout
		demoWrapper.onmouseout = function() {
		tooltip.style.display = 'none';
		};
		/* tooltip code end */
	</script>


</body>
</html>
